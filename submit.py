# -*- coding: utf-8 -*-
"""submit.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18THH5wSVHLaF_oOO_HXdMy61NpoeiULr
"""

import numpy as np

def my_decode(w):
    """
    Takes a 65-dimensional linear model w as input and returns four
    64-dimensional non-negative delay vectors: p, q, r, s
    """

    # Ensure w is a 1D array
    w = np.asarray(w).flatten()

    # Separate out the bias term
    w_bias = w[-1]
    w_main = w[:-1]  # This is of shape (64,)

    # Initialize delay vectors
    alpha = np.copy(w_main)
    beta = np.copy(w_main)

    # Following the relation:
    # w = alpha + beta (excluding last element)
    # and w = alpha - beta (shifted version)

    # Solve for alpha and beta using equations:
    # alpha = (w[i] + w[i+1]) / 2
    # beta  = (w[i] - w[i+1]) / 2
    alpha = (w_main + np.roll(w_main, -1)) / 2
    beta = (w_main - np.roll(w_main, -1)) / 2

    # Remove the wrap-around artifact in last value
    alpha[-1] = w_main[-1] / 2
    beta[-1] = w_main[-1] / 2

    # Construct p, q, r, s from alpha and beta
    p = np.maximum(alpha, 0)
    q = np.maximum(-alpha, 0)
    r = np.maximum(beta, 0)
    s = np.maximum(-beta, 0)

    return p, q, r, s